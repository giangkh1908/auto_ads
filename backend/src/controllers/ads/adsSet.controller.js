// controllers/ads/adsSet.controller.js
import AdsSet from "../../models/ads/adsSet.model.js";
import { syncAdSetsFromFacebook, fetchAdsetsFromFacebook, updateAdsetStatus, deleteEntity, fetchInsightsForEntities } from "../../services/fbAdsService.js";
import User from "../../models/user.model.js";
import Ads from "../../models/ads/ads.model.js";

// Helper function ƒë·ªÉ extract string ID t·ª´ ObjectId format
function extractObjectId(value) {
  if (!value) return null;
  if (typeof value === 'string') {
    const match = value.match(/[0-9a-fA-F]{24}/);
    return match ? match[0] : null;
  }
  if (value.$oid) return value.$oid; // trong tr∆∞·ªùng h·ª£p Mongo xu·∫•t ra ki·ªÉu { $oid: '...' }
  return value.toString();
}

// L·∫•y list status c·ªßa tr·∫°ng th√°i on/off ads
export async function toggleAdsetStatusCtrl(req, res) {
  try {
    const { id } = req.params; // Facebook adset id
    const { status } = req.body; // "ACTIVE" | "PAUSED"
    if (!id || !status) return res.status(400).json({ message: "Thi·∫øu id ho·∫∑c status" });

    const user = await User.findById(req.user?._id).select("+facebookAccessToken");
    const accessToken = user?.facebookAccessToken;
    if (!accessToken) return res.status(401).json({ message: "Thi·∫øu access token Facebook" });

    await updateAdsetStatus(id, accessToken, status);
    return res.status(200).json({ success: true });
  } catch (err) {
    console.error("Toggle adset status error:", err.response?.data || err.message);
    return res.status(500).json({ message: "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i adset", detail: err.response?.data || err.message });
  }
}
/**
 * GET /api/adsets/database
 * L·∫•y adset t·ª´ database theo adset_id ho·∫∑c campaign_id
 */
export async function getAdsetFromDatabase(req, res) {
  try {
    const { adset_id, campaign_id } = req.query;
    
    if (!adset_id && !campaign_id) {
      return res.status(400).json({
        success: false,
        message: "Thi·∫øu adset_id ho·∫∑c campaign_id"
      });
    }

    // Extract v√† validate adset_id n·∫øu c√≥
    const cleanAdsetId = extractObjectId(adset_id);
    if (adset_id && !cleanAdsetId) {
      return res.status(400).json({
        success: false,
        message: "adset_id kh√¥ng h·ª£p l·ªá"
      });
    }

    // Extract v√† validate campaign_id n·∫øu c√≥
    const cleanCampaignId = extractObjectId(campaign_id);
    if (campaign_id && !cleanCampaignId) {
      return res.status(400).json({
        success: false,
        message: "campaign_id kh√¥ng h·ª£p l·ªá"
      });
    }

    let adset;
    if (cleanAdsetId) {
      adset = await AdsSet.findById(cleanAdsetId).populate('created_by', 'full_name email');
    } else if (cleanCampaignId) {
      const adsets = await AdsSet.find({ campaign_id: cleanCampaignId })
        .populate('created_by', 'full_name email')
        .sort({ createdAt: -1 });
      return res.status(200).json({
        success: true,
        data: adsets
      });
    }
    
    if (!adset) {
      return res.status(404).json({
        success: false,
        message: "Kh√¥ng t√¨m th·∫•y adset"
      });
    }

    return res.status(200).json({
      success: true,
      data: adset
    });
  } catch (err) {
    console.error("GET Adset from database error:", err);
    return res.status(500).json({
      success: false,
      message: "L·ªói khi l·∫•y adset t·ª´ database",
      error: err.message
    });
  }
}

/**
 * GET /api/adsets
 * L·∫•y danh s√°ch nh√≥m qu·∫£ng c√°o
 */
export async function listAdSetsCtrl(req, res) {
  try {
    const { account_id, campaign_id, q, status, page = 1, limit = 10 } = req.query;

    const filter = {};

    // ‚úÖ Lu√¥n lo·∫°i b·ªè items ƒë√£ DELETED ·ªü backend
    filter.status = { $ne: "DELETED" };
    
    if (account_id) {
      const normalizedId = account_id.startsWith("act_")
        ? account_id.substring(4)
        : account_id;
      filter.external_account_id = { $in: [normalizedId, `act_${normalizedId}`] };
    }

    if (campaign_id) filter.campaign_id = campaign_id;
    // N·∫øu c√≥ filter status c·ª• th·ªÉ, ghi ƒë√® filter m·∫∑c ƒë·ªãnh
    if (status) filter.status = status;
    if (q) filter.name = new RegExp(q, "i");

    const skip = (Number(page) - 1) * Number(limit);
    const [items, total] = await Promise.all([
      AdsSet.find(filter)
        .populate('created_by', 'full_name email')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(Number(limit)),
      AdsSet.countDocuments(filter),
    ]);

    return res.status(200).json({
      items,
      total,
      page: Number(page),
      limit: Number(limit),
      pages: Math.ceil(total / Number(limit)) || 1,
    });
  } catch (err) {
    console.error("GET AdSets error:", err);
    return res.status(500).json({
      message: "L·ªói khi l·∫•y danh s√°ch nh√≥m qu·∫£ng c√°o",
      error: err.message,
    });
  }
}
/**
 * GET /api/adsets/sync
 * ƒê·ªìng b·ªô nh√≥m qu·∫£ng c√°o t·ª´ Facebook
 */
export async function syncAdSetsCtrl(req, res) {
  try {
    const { account_id } = req.query;
    if (!account_id) {
      return res.status(400).json({ message: "Thi·∫øu account_id" });
    }

    // L·∫•y token: ∆∞u ti√™n query, fallback DB c·ªßa user hi·ªán t·∫°i
    let accessToken = req.query.access_token;
    if (!accessToken && req.user?._id) {
      const user = await User.findById(req.user._id).select("+facebookAccessToken");
      accessToken = user?.facebookAccessToken || null;
    }

    if (!accessToken) {
      return res.status(400).json({
        message: "Kh√¥ng t√¨m th·∫•y Facebook access_token. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.",
        missingToken: true,
      });
    }

    const results = await syncAdSetsFromFacebook(accessToken, account_id);
    return res.status(200).json({
      message: `ƒê√£ ƒë·ªìng b·ªô ${results.length} nh√≥m qu·∫£ng c√°o t·ª´ Facebook`,
      count: results.length,
    });
  } catch (err) {
    console.error("SYNC AdSets error:", err);
    return res.status(500).json({
      message: "L·ªói khi ƒë·ªìng b·ªô nh√≥m qu·∫£ng c√°o t·ª´ Facebook",
      error: err.message,
    });
  }
}

/**
 * GET /api/adsets/live
 * L·∫•y danh s√°ch adsets tr·ª±c ti·∫øp t·ª´ Facebook (kh√¥ng l∆∞u DB)
 */
export async function getAdSetsLiveCtrl(req, res) {
  try {
    const { account_id } = req.query;
    if (!account_id) {
      return res.status(400).json({ message: "Thi·∫øu account_id" });
    }

    let accessToken = req.query.access_token;
    if (!accessToken) {
      const user = await User.findById(req.user?._id).select("+facebookAccessToken");
      accessToken = user?.facebookAccessToken || null;
    }
    if (!accessToken) {
      return res.status(400).json({
        message: "Kh√¥ng t√¨m th·∫•y Facebook access_token. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.",
        missingToken: true,
      });
    }

    const data = await fetchAdsetsFromFacebook(accessToken, account_id);
    return res.status(200).json({ items: data, total: data.length });
  } catch (err) {
    console.error("GET Live AdSets error:", err);
    return res.status(500).json({ message: "L·ªói l·∫•y adsets t·ª´ Facebook", error: err.message });
  }
}

/**
 * DELETE /api/adsets/:id
 * X√≥a AdSet + to√†n b·ªô Ads con
 * - C√≥ token: x√≥a th·∫≠t tr√™n Facebook
 * - Kh√¥ng c√≥ token: x√≥a m·ªÅm trong DB
 */
export async function deleteAdsetCascadeCtrl(req, res) {
  try {
    const { id } = req.params;
    const adset = await AdsSet.findById(id);
    if (!adset) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y nh√≥m qu·∫£ng c√°o." });

    // ‚úÖ L·∫•y access_token t·ª´ user ho·∫∑c query
    let accessToken = req.user?.facebookAccessToken || req.query.access_token || null;

    if (!accessToken && req.user?._id) {
      const user = await User.findById(req.user._id).select("+facebookAccessToken");
      accessToken = user?.facebookAccessToken || null;
    }

    if (!accessToken) {
      console.warn("‚ö†Ô∏è Kh√¥ng c√≥ Facebook access_token ‚Äî ch·ªâ x√≥a m·ªÅm trong DB.");
    }

    // L·∫•y to√†n b·ªô ads con trong adset
    const ads = await Ads.find({ set_id: adset._id });

    // ‚úÖ X√≥a th·∫≠t tr√™n Facebook n·∫øu c√≥ token
    if (accessToken) {
      try {
        // X√≥a t·∫•t c·∫£ ads tr∆∞·ªõc
        for (const ad of ads) {
          if (ad.external_id) await deleteEntity(ad.external_id, accessToken);
        }

        // Sau ƒë√≥ x√≥a adset
        if (adset.external_id) await deleteEntity(adset.external_id, accessToken);

        console.log(`üßπ ƒê√£ xo√° th·∫≠t adset ${adset.name} (${adset.external_id}) v√† ${ads.length} ads tr√™n Facebook`);
      } catch (fbErr) {
        console.warn("‚ö†Ô∏è L·ªói khi xo√° adset ho·∫∑c ads tr√™n Facebook:", fbErr?.response?.data || fbErr.message);
      }
    }

    // ‚úÖ X√≥a m·ªÅm trong DB
    const now = new Date();
    await Promise.all([
      Ads.updateMany({ set_id: adset._id }, { status: "DELETED", deleted_at: now }),
      AdsSet.findByIdAndUpdate(id, { status: "DELETED", deleted_at: now }),
    ]);

    return res.status(200).json({
      success: true,
      message: `ƒê√£ xo√° nh√≥m qu·∫£ng c√°o "${adset.name}" v√† ${ads.length} qu·∫£ng c√°o li√™n quan.`,
    });
  } catch (err) {
    console.error("‚ùå Xo√° AdSet cascade l·ªói:", err);
    return res.status(500).json({
      message: "Xo√° th·∫•t b·∫°i",
      error: err.message,
    });
  }
}

/**
 * POST /api/adsets/:id/copy
 * T·∫°o b·∫£n sao AdSet k√®m to√†n b·ªô Ads con (DB only)
 */
export async function copyAdsetCascadeCtrl(req, res) {
  try {
    const { id } = req.params;
    const source = await AdsSet.findById(id);
    if (!source) return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y nh√≥m qu·∫£ng c√°o." });

    const newAdset = await AdsSet.create({
      campaign_id: source.campaign_id,
      external_account_id: source.external_account_id,
      name: `${source.name || "Nh√≥m qu·∫£ng c√°o"} (b·∫£n sao)`,
      status: "IN_PROCESS",
      configured_status: source.configured_status,
      effective_status: source.effective_status,
      optimization_goal: source.optimization_goal,
      billing_event: source.billing_event,
      bid_strategy: source.bid_strategy,
      bid_amount: source.bid_amount,
      pixel_id: source.pixel_id,
      conversion_event: source.conversion_event,
      promoted_object: source.promoted_object,
      targeting: source.targeting,
      daily_budget: source.daily_budget,
      lifetime_budget: source.lifetime_budget,
      start_time: source.start_time,
      end_time: source.end_time,
      external_id: null,
    });

    const ads = await Ads.find({ set_id: source._id }).lean();
    for (const a of ads) {
      await Ads.create({
        name: `${a.name || "Qu·∫£ng c√°o"} (b·∫£n sao)`,
        status: "IN_PROCESS",
        external_id: null,
        external_account_id: a.external_account_id,
        set_id: newAdset._id,
        campaign_id: source.campaign_id,
        effective_status: a.effective_status,
        creative: a.creative,
      });
    }

    return res.status(201).json({ success: true, message: "ƒê√£ sao ch√©p AdSet c√πng Ads.", data: { adset: newAdset } });
  } catch (err) {
    console.error("‚ùå Copy AdSet cascade l·ªói:", err);
    return res.status(500).json({ message: "Copy th·∫•t b·∫°i", error: err.message });
  }
}

/**
 * GET /api/adsets/insights
 * L·∫•y insights cho nhi·ªÅu adsets t·ª´ Facebook
 */
export async function getAdsetInsightsCtrl(req, res) {
  try {
    const { ids } = req.query;
    if (!ids) {
      return res.status(400).json({ message: "Thi·∫øu danh s√°ch IDs" });
    }

    const adsetIds = ids.split(',');

    // L·∫•y token ng∆∞·ªùi d√πng hi·ªán t·∫°i
    const user = await User.findById(req.user?._id).select("+facebookAccessToken");
    const accessToken = user?.facebookAccessToken;
    if (!accessToken) {
      return res.status(401).json({ message: "Thi·∫øu access token Facebook" });
    }

    // G·ªçi service ƒë·ªÉ l·∫•y insights
    const insightsData = await fetchInsightsForEntities(adsetIds, accessToken);

    // Map l·∫°i data ƒë·ªÉ FE d·ªÖ x·ª≠ l√Ω: { id: '...', insights: {...} }
    const items = insightsData.map(item => ({
      id: item.id,
      insights: item.insights?.data?.[0] || {}
    }));

    return res.status(200).json({ items });

  } catch (err) {
    console.error("GET Adset Insights error:", err.response?.data || err.message);
    return res.status(500).json({ 
      message: "Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu insights", 
      detail: err.response?.data || err.message 
    });
  }
}
